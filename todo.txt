
currently, the memory section of the module is ignored.
if there is no memory import, one is defined, whether
the module had a memory section or not.  do we need 
a way to specify a module which has no memory at all?

Target.Nothing should probably be folded into Target.Other

should probably lookup all references in a ns2.0 reference
assembly

when mem is imported because wasi, the field(s) should
be in the wasi class.

wasi would end up being a compile option of ours.
when it is set, the wasi assembly is made available,
and the memory import/export is ignored in favor of
using the one in the wasi core class.

separate out the wasi stuff into its own thing.  and
call it wasi core.

what else is in wasi sysroot?  math stuff like pow() ?
is it a problem if those funcs get used instead of the
ones in System.Math?

or perhaps the code could have special knowledge
of the wasi module and do some initialization of it?

the problem is that funcs like fd_write get
addresses that need to be looked up in mem.
so whenever wasi is used, --import-memory must
be used as well.

consider --import-memory

how to do mem_size ?  should the memory be a struct
instead of just an IntPtr ?

only one copy of memory, shared by all the tests?
most tests need a private memory, not ref the
imported one in env.  but can we reference an
internal memory from a test?

does the env code need access to the mem size?

or maybe just insist that if the memory is
imported then the mem_size must be there to import
as well?

it would still be kind of better to just always have
memory imported, but the problem is the test suite,
where all tests share the same memory.

--

is the sysroot libc buffering?  why is ppm file
missing the last 350 bytes?

need tests for f64/i64 reinterpret

miniray seems to be accessing memory outside the
range of a page.  65536 is a page.  add 1024
to get 66560, which is the number given. maybe related:
ouch.  results vary from run to run, even without
a rebuild.

test min and max?

xunit theory instead of fact

sqlite docs say the OMIT defines don't work for the
amalgamation

sqlite compile needs i64ctlz

some combinations of compare/BrIf could probably
be merged into CIL like Beq.  like a peephole
optimization.

stack cleanup around br and friends.  write failing
test cases for this.

things that are tricky could be implemented in C# in env
and just import and call out to it.  but long term,
it might be better to require env only for cases where
something was imported.  a module that imports nothing
should ideally result in an assembly that has no
dependencies.

need more tests of invalid wasm

it would be nice to throw even more specific exceptions
so the tests can be more precise in error cases

memory load/store operations are supposed to be
range-checked

should use the short form of more CIL instructions,
like Ldloc

consider possibility of just using int everywhere
a uint32 is used, because that's just how .NET
does things, with array indexes and such being
int instead of unsigned

--

want to eventually package this as a dotnet global tool

maybe we need a func to emit an expression for init cases, 
more limited

not sure how imported table makes sense

need some tests to verify read/write of the binary
format

--

consider using the actual wasm opcode name
for the union labels, with `` ?

might like the ability to output a wasm module
as F# to reconstruct it with Builder

consistency question about the final End opcode

--

hmmm.  consider system.reflection.metadata
instead of Cecil ?

--

how to make clang not generate refs to soft fp functions?

how to deal with non-mut globals?

consider an F# wrapper around cecil, avoid all those
il.Create() overloads, so problems can be caught at
compile time instead of run time.

still some problems in roundtripping binary format,
might be important, not sure

need consistency about whether to pass around
wrapped indexes or just the ints

consider using checked int operations in leb128 code

best practice for formatting fs, type annotations, colon

def and read and write and cecil could be in separate assemblies?

review naming of def record fields.  compare to spec.
and conventions, lower case, etc.

chg assembly write to use a stream ?

