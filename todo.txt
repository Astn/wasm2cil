
need to get away from using Prefix_ for
union labels or record field labels.

consider using the actual wasm opcode name
for the union labels, with ``

https://github.com/SteveGilham/altcover

might like the ability to output a wasm module
as F# to reconstruct it with Builder

consistency question about the final End opcode

should coalesce the datas into one big data in just
one resource?  except each one gets its own offset
which is expressed in wasm opcodes that need to be
executed.  but we could check the opcodes to see if
it's just a constant.

implement data segments

how to store the datas?

the Emit implementations are using DefineInitializedData,
which seems to be a field that is a value type of a
certain size.  the data gets put in the .sdata section,
and then something loads it and puts it in the field,
so then it's easy to just take the address of the field
and memcpy.  works nicely, but I can't figure out how
to make Mono.Cecil do that.

this notion is called a mapped field.  and it arguably
was not designed to be used for data initialization
with blobs.  it seems to be designed for primitive
types, and technically, yeah, it's possible to
use it for struct types with lots of byte fields,
but that's apparently not the use case it was designed for.

dumb idea would be to just inline tons of single-byte
store instructions in the cctor.  or do 8 bytes at a
time with remainder at the end.

or store the data in a resource, and in the cctor, load
it and store it.

or is there some other way to get the data into the
.sdata section and then access it from CIL instructions?

hmmm.  consider system.reflection.metadata?

or AbsIL?

--

need tables for CallIndirect

how to do tests?  construct a program using defs.
write it to a file.  read it back.  verify.
compile it to an assembly.  load the assembly.
run it.  verify the result.

why doesn't clang generate any globals?

how to make clang not generate refs to soft fp functions?

how does an imported memory work?  probably
depends on the tool that compiled the wasm.

how to deal with non-mut globals?

consider an F# wrapper around cecil, avoid all those
il.Create() overloads

how to implement data initialization for an imported
memory.  static constructor?

how to deal with select without knowing the type
of the args on the stack?  need to keep track of
them.  which means needing to know how every op
affects the stack.

does br need to do stack cleanup ?

why doesn't clang mark exports ?

return value from blocks ?

still some problems in roundtripping binary format,
might be important, not sure

need consistency about whether to pass around
wrapped indexes or just the ints

consider possibility of just using int everywhere
a uint32 is used, because that's just how .NET
does things, with array indexes and such being
int instead of unsigned

consider using checked int operations in leb128 code

best practice for formatting fs, type annotations, colon

def and read and write and cecil could be in separate assemblies?

review naming of def record fields.  compare to spec.
and conventions, lower case, etc.

